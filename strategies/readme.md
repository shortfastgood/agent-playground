# Use Cases Strategy

## Pull Request Verification

## Legacy Code Modernization

## Automated Testing

## Image Analysis

### Use Case Reverse Engineering of a Widget

To achieve a good result, simplicity is the best tool. If we are dealing with a complex representation, it is advisable to analyze and generate the code for each part separately. Subsequently, the codes can be recombined to recreate the complex surface.

Similarly, with the prompt, it is better not to insist on too many details. An essential request generally leads to a better initial structure. Details omitted can later be added with subsequent improvements through prompts.

The first step is to ask the model for an analysis of the image. The response provides the starting point for generating the code. It is important to use expressions and words from the model's response to formulate the request that generates the code.

See [research/use-case-widget-reverse-engineering/description.md](research/use-case-widget-reverse-engineering/description.md) for a detailed description of the use case.

#### Results

Testing the described strategy does not lead to good results without many corrections. The limitations are in the image, even the best language model does not have the ability to extract all the information that a person immediately sees. Furthermore, there are no reliable models for low-cost local processing. We conclude that this is not a good strategy for working with artificial intelligence.

The final test using a document specifying all the characteristics of the widget has proven to be a better and more reliable strategy. Subsequent corrections have always concerned details that were forgotten or poorly evaluated when the specification was written.

[Specification](specification.md) is a document that describes the widget in detail. The document is not intended to be used as a prompt, but rather as a reference for the model to understand the widget's characteristics and behavior. The document is not exhaustive and does not cover all possible cases, but it provides a good starting point for generating the code.

[Widget Code](widget_code.dart) is the code generated by the model based on the specification. The code is not guaranteed to be functional and may require adjustments. The code is intended for use in Flutter and Dart and requires an account on the [FlutLab](https://flutlab.io/) platform to be run.

[Widget Test](widget_test.dart) is the test code generated by the model based on the widget code. The test code is not guaranteed to be functional and may require adjustments. The test code is intended for use in Flutter and Dart and requires an account on the [FlutLab](https://flutlab.io/) platform to be run.

![portrait](../research/Use-Case-Widget-Reverse-Engineering/copilot-flutter-donut-portrait.png)

![landscape](../research/Use-Case-Widget-Reverse-Engineering/copilot-flutter-donut-landscape.png)